'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Compressor;

var _zstream = require('pako/lib/zlib/zstream');

var _zstream2 = _interopRequireDefault(_zstream);

var _deflate = require('pako/lib/zlib/deflate');

var _inflate = require('pako/lib/zlib/inflate');

var _messages = require('pako/lib/zlib/messages.js');

var _messages2 = _interopRequireDefault(_messages);

var _constants = require('pako/lib/zlib/constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const CHUNK_SIZE = 16384;
const WINDOW_BITS = 15;

/**
 * Handles de-/compression via #inflate() and #deflate(), calls you back via #deflatedReady() and #inflatedReady().
 * The chunk we get from deflater is actually a view of a 16kB arraybuffer, so we need to copy the relevant parts
 * memory to a new arraybuffer.
 */
function Compressor(inflatedReady, deflatedReady) {
  this.inflatedReady = inflatedReady;
  this.deflatedReady = deflatedReady;
  this._inflate = inflater(chunk => this.inflatedReady(chunk.buffer.slice(chunk.byteOffset, chunk.byteOffset + chunk.length)));
  this._deflate = deflater(chunk => this.deflatedReady(chunk.buffer.slice(chunk.byteOffset, chunk.byteOffset + chunk.length)));
}

Compressor.prototype.inflate = function (buffer) {
  this._inflate(new Uint8Array(buffer));
};

Compressor.prototype.deflate = function (buffer) {
  this._deflate(new Uint8Array(buffer));
};

function deflater(emit) {
  const stream = new _zstream2.default();
  let status = (0, _deflate.deflateInit2)(stream, _constants.Z_DEFAULT_COMPRESSION, _constants.Z_DEFLATED, WINDOW_BITS, 8, _constants.Z_DEFAULT_STRATEGY);
  if (status !== _constants.Z_OK) {
    throw new Error('Problem initializing deflate stream: ' + _messages2.default[status]);
  }

  return function (data) {
    if (data === undefined) return emit();

    // Attach the input data
    stream.input = data;
    stream.next_in = 0;
    stream.avail_in = stream.input.length;

    let status;
    let output;
    let start;
    let ret = true;

    do {
      // When the stream gets full, we need to create new space.
      if (stream.avail_out === 0) {
        stream.output = new Uint8Array(CHUNK_SIZE);
        start = stream.next_out = 0;
        stream.avail_out = CHUNK_SIZE;
      }

      // Perform the deflate
      status = (0, _deflate.deflate)(stream, _constants.Z_SYNC_FLUSH);
      if (status !== _constants.Z_STREAM_END && status !== _constants.Z_OK) {
        throw new Error('Deflate problem: ' + _messages2.default[status]);
      }

      // If the output buffer got full, flush the data.
      if (stream.avail_out === 0 && stream.next_out > start) {
        output = stream.output.subarray(start, start = stream.next_out);
        ret = emit(output);
      }
    } while ((stream.avail_in > 0 || stream.avail_out === 0) && status !== _constants.Z_STREAM_END);

    // Emit whatever is left in output.
    if (stream.next_out > start) {
      output = stream.output.subarray(start, start = stream.next_out);
      ret = emit(output);
    }
    return ret;
  };
}

function inflater(emit) {
  let stream = new _zstream2.default();

  const status = (0, _inflate.inflateInit2)(stream, WINDOW_BITS);
  if (status !== _constants.Z_OK) {
    throw new Error('Problem initializing inflate stream: ' + _messages2.default[status]);
  }

  return function (data) {
    if (data === undefined) return emit();

    let start;
    stream.input = data;
    stream.next_in = 0;
    stream.avail_in = stream.input.length;

    let status, output;
    let ret = true;

    do {
      if (stream.avail_out === 0) {
        stream.output = new Uint8Array(CHUNK_SIZE);
        start = stream.next_out = 0;
        stream.avail_out = CHUNK_SIZE;
      }

      status = (0, _inflate.inflate)(stream, _constants.Z_NO_FLUSH);
      if (status !== _constants.Z_STREAM_END && status !== _constants.Z_OK) {
        throw new Error('inflate problem: ' + _messages2.default[status]);
      }

      if (stream.next_out) {
        if (stream.avail_out === 0 || status === _constants.Z_STREAM_END) {
          output = stream.output.subarray(start, start = stream.next_out);
          ret = emit(output);
        }
      }
    } while (stream.avail_in > 0 && status !== _constants.Z_STREAM_END);

    if (stream.next_out > start) {
      output = stream.output.subarray(start, start = stream.next_out);
      ret = emit(output);
    }

    return ret;
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jb21wcmVzc2lvbi5qcyJdLCJuYW1lcyI6WyJDb21wcmVzc29yIiwiQ0hVTktfU0laRSIsIldJTkRPV19CSVRTIiwiaW5mbGF0ZWRSZWFkeSIsImRlZmxhdGVkUmVhZHkiLCJfaW5mbGF0ZSIsImluZmxhdGVyIiwiY2h1bmsiLCJidWZmZXIiLCJzbGljZSIsImJ5dGVPZmZzZXQiLCJsZW5ndGgiLCJfZGVmbGF0ZSIsImRlZmxhdGVyIiwicHJvdG90eXBlIiwiaW5mbGF0ZSIsIlVpbnQ4QXJyYXkiLCJkZWZsYXRlIiwiZW1pdCIsInN0cmVhbSIsInN0YXR1cyIsIkVycm9yIiwiZGF0YSIsInVuZGVmaW5lZCIsImlucHV0IiwibmV4dF9pbiIsImF2YWlsX2luIiwib3V0cHV0Iiwic3RhcnQiLCJyZXQiLCJhdmFpbF9vdXQiLCJuZXh0X291dCIsInN1YmFycmF5Il0sIm1hcHBpbmdzIjoiOzs7OztrQkFrQndCQSxVOztBQWxCeEI7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBTUEsTUFBTUMsYUFBYSxLQUFuQjtBQUNBLE1BQU1DLGNBQWMsRUFBcEI7O0FBRUE7Ozs7O0FBS2UsU0FBU0YsVUFBVCxDQUFxQkcsYUFBckIsRUFBb0NDLGFBQXBDLEVBQW1EO0FBQ2hFLE9BQUtELGFBQUwsR0FBcUJBLGFBQXJCO0FBQ0EsT0FBS0MsYUFBTCxHQUFxQkEsYUFBckI7QUFDQSxPQUFLQyxRQUFMLEdBQWdCQyxTQUFTQyxTQUFTLEtBQUtKLGFBQUwsQ0FBbUJJLE1BQU1DLE1BQU4sQ0FBYUMsS0FBYixDQUFtQkYsTUFBTUcsVUFBekIsRUFBcUNILE1BQU1HLFVBQU4sR0FBbUJILE1BQU1JLE1BQTlELENBQW5CLENBQWxCLENBQWhCO0FBQ0EsT0FBS0MsUUFBTCxHQUFnQkMsU0FBU04sU0FBUyxLQUFLSCxhQUFMLENBQW1CRyxNQUFNQyxNQUFOLENBQWFDLEtBQWIsQ0FBbUJGLE1BQU1HLFVBQXpCLEVBQXFDSCxNQUFNRyxVQUFOLEdBQW1CSCxN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cyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBaU3RyZWFtIGZyb20gJ3Bha28vbGliL3psaWIvenN0cmVhbSdcbmltcG9ydCB7IGRlZmxhdGVJbml0MiwgZGVmbGF0ZSB9IGZyb20gJ3Bha28vbGliL3psaWIvZGVmbGF0ZSdcbmltcG9ydCB7IGluZmxhdGUsIGluZmxhdGVJbml0MiB9IGZyb20gJ3Bha28vbGliL3psaWIvaW5mbGF0ZSdcbmltcG9ydCBtZXNzYWdlcyBmcm9tICdwYWtvL2xpYi96bGliL21lc3NhZ2VzLmpzJ1xuaW1wb3J0IHtcbiAgWl9OT19GTFVTSCwgWl9TWU5DX0ZMVVNILCBaX09LLFxuICBaX1NUUkVBTV9FTkQsIFpfREVGQVVMVF9DT01QUkVTU0lPTixcbiAgWl9ERUZBVUxUX1NUUkFURUdZLCBaX0RFRkxBVEVEXG59IGZyb20gJ3Bha28vbGliL3psaWIvY29uc3RhbnRzJ1xuXG5jb25zdCBDSFVOS19TSVpFID0gMTYzODRcbmNvbnN0IFdJTkRPV19CSVRTID0gMTVcblxuLyoqXG4gKiBIYW5kbGVzIGRlLS9jb21wcmVzc2lvbiB2aWEgI2luZmxhdGUoKSBhbmQgI2RlZmxhdGUoKSwgY2FsbHMgeW91IGJhY2sgdmlhICNkZWZsYXRlZFJlYWR5KCkgYW5kICNpbmZsYXRlZFJlYWR5KCkuXG4gKiBUaGUgY2h1bmsgd2UgZ2V0IGZyb20gZGVmbGF0ZXIgaXMgYWN0dWFsbHkgYSB2aWV3IG9mIGEgMTZrQiBhcnJheWJ1ZmZlciwgc28gd2UgbmVlZCB0byBjb3B5IHRoZSByZWxldmFudCBwYXJ0c1xuICogbWVtb3J5IHRvIGEgbmV3IGFycmF5YnVmZmVyLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDb21wcmVzc29yIChpbmZsYXRlZFJlYWR5LCBkZWZsYXRlZFJlYWR5KSB7XG4gIHRoaXMuaW5mbGF0ZWRSZWFkeSA9IGluZmxhdGVkUmVhZHlcbiAgdGhpcy5kZWZsYXRlZFJlYWR5ID0gZGVmbGF0ZWRSZWFkeVxuICB0aGlzLl9pbmZsYXRlID0gaW5mbGF0ZXIoY2h1bmsgPT4gdGhpcy5pbmZsYXRlZFJlYWR5KGNodW5rLmJ1ZmZlci5zbGljZShjaHVuay5ieXRlT2Zmc2V0LCBjaHVuay5ieXRlT2Zmc2V0ICsgY2h1bmsubGVuZ3RoKSkpXG4gIHRoaXMuX2RlZmxhdGUgPSBkZWZsYXRlcihjaHVuayA9PiB0aGlzLmRlZmxhdGVkUmVhZHkoY2h1bmsuYnVmZmVyLnNsaWNlKGNodW5rLmJ5dGVPZmZzZXQsIGNodW5rLmJ5dGVPZmZzZXQgKyBjaHVuay5sZW5ndGgpKSlcbn1cblxuQ29tcHJlc3Nvci5wcm90b3R5cGUuaW5mbGF0ZSA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgdGhpcy5faW5mbGF0ZShuZXcgVWludDhBcnJheShidWZmZXIpKVxufVxuXG5Db21wcmVzc29yLnByb3RvdHlwZS5kZWZsYXRlID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICB0aGlzLl9kZWZsYXRlKG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpXG59XG5cbmZ1bmN0aW9uIGRlZmxhdGVyIChlbWl0KSB7XG4gIGNvbnN0IHN0cmVhbSA9IG5ldyBaU3RyZWFtKClcbiAgbGV0IHN0YXR1cyA9IGRlZmxhdGVJbml0MihzdHJlYW0sIFpfREVGQVVMVF9DT01QUkVTU0lPTiwgWl9ERUZMQVRFRCwgV0lORE9XX0JJVFMsIDgsIFpfREVGQVVMVF9TVFJBVEVHWSlcbiAgaWYgKHN0YXR1cyAhPT0gWl9PSykge1xuICAgIHRocm93IG5ldyBFcnJvcignUHJvYmxlbSBpbml0aWFsaXppbmcgZGVmbGF0ZSBzdHJlYW06ICcgKyBtZXNzYWdlc1tzdGF0dXNdKVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGVtaXQoKVxuXG4gICAgLy8gQXR0YWNoIHRoZSBpbnB1dCBkYXRhXG4gICAgc3RyZWFtLmlucHV0ID0gZGF0YVxuICAgIHN0cmVhbS5uZXh0X2luID0gMFxuICAgIHN0cmVhbS5hdmFpbF9pbiA9IHN0cmVhbS5pbnB1dC5sZW5ndGhcblxuICAgIGxldCBzdGF0dXNcbiAgICBsZXQgb3V0cHV0XG4gICAgbGV0IHN0YXJ0XG4gICAgbGV0IHJldCA9IHRydWVcblxuICAgIGRvIHtcbiAgICAgIC8vIFdoZW4gdGhlIHN0cmVhbSBnZXRzIGZ1bGwsIHdlIG5lZWQgdG8gY3JlYXRlIG5ldyBzcGFjZS5cbiAgICAgIGlmIChzdHJlYW0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHN0cmVhbS5vdXRwdXQgPSBuZXcgVWludDhBcnJheShDSFVOS19TSVpFKVxuICAgICAgICBzdGFydCA9IHN0cmVhbS5uZXh0X291dCA9IDBcbiAgICAgICAgc3RyZWFtLmF2YWlsX291dCA9IENIVU5LX1NJWkVcbiAgICAgIH1cblxuICAgICAgLy8gUGVyZm9ybSB0aGUgZGVmbGF0ZVxuICAgICAgc3RhdHVzID0gZGVmbGF0ZShzdHJlYW0sIFpfU1lOQ19GTFVTSClcbiAgICAgIGlmIChzdGF0dXMgIT09IFpfU1RSRUFNX0VORCAmJiBzdGF0dXMgIT09IFpfT0spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWZsYXRlIHByb2JsZW06ICcgKyBtZXNzYWdlc1tzdGF0dXNdKVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgb3V0cHV0IGJ1ZmZlciBnb3QgZnVsbCwgZmx1c2ggdGhlIGRhdGEuXG4gICAgICBpZiAoc3RyZWFtLmF2YWlsX291dCA9PT0gMCAmJiBzdHJlYW0ubmV4dF9vdXQgPiBzdGFydCkge1xuICAgICAgICBvdXRwdXQgPSBzdHJlYW0ub3V0cHV0LnN1YmFycmF5KHN0YXJ0LCBzdGFydCA9IHN0cmVhbS5uZXh0X291dClcbiAgICAgICAgcmV0ID0gZW1pdChvdXRwdXQpXG4gICAgICB9XG4gICAgfSB3aGlsZSAoKHN0cmVhbS5hdmFpbF9pbiA+IDAgfHwgc3RyZWFtLmF2YWlsX291dCA9PT0gMCkgJiYgc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQpXG5cbiAgICAvLyBFbWl0IHdoYXRldmVyIGlzIGxlZnQgaW4gb3V0cHV0LlxuICAgIGlmIChzdHJlYW0ubmV4dF9vdXQgPiBzdGFydCkge1xuICAgICAgb3V0cHV0ID0gc3RyZWFtLm91dHB1dC5zdWJhcnJheShzdGFydCwgc3RhcnQgPSBzdHJlYW0ubmV4dF9vdXQpXG4gICAgICByZXQgPSBlbWl0KG91dHB1dClcbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVyIChlbWl0KSB7XG4gIGxldCBzdHJlYW0gPSBuZXcgWlN0cmVhbSgpXG5cbiAgY29uc3Qgc3RhdHVzID0gaW5mbGF0ZUluaXQyKHN0cmVhbSwgV0lORE9XX0JJVFMpXG4gIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2JsZW0gaW5pdGlhbGl6aW5nIGluZmxhdGUgc3RyZWFtOiAnICsgbWVzc2FnZXNbc3RhdHVzXSlcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHJldHVybiBlbWl0KClcblxuICAgIGxldCBzdGFydFxuICAgIHN0cmVhbS5pbnB1dCA9IGRhdGFcbiAgICBzdHJlYW0ubmV4dF9pbiA9IDBcbiAgICBzdHJlYW0uYXZhaWxfaW4gPSBzdHJlYW0uaW5wdXQubGVuZ3RoXG5cbiAgICBsZXQgc3RhdHVzLCBvdXRwdXRcbiAgICBsZXQgcmV0ID0gdHJ1ZVxuXG4gICAgZG8ge1xuICAgICAgaWYgKHN0cmVhbS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgc3RyZWFtLm91dHB1dCA9IG5ldyBVaW50OEFycmF5KENIVU5LX1NJWkUpXG4gICAgICAgIHN0YXJ0ID0gc3RyZWFtLm5leHRfb3V0ID0gMFxuICAgICAgICBzdHJlYW0uYXZhaWxfb3V0ID0gQ0hVTktfU0laRVxuICAgICAgfVxuXG4gICAgICBzdGF0dXMgPSBpbmZsYXRlKHN0cmVhbSwgWl9OT19GTFVTSClcbiAgICAgIGlmIChzdGF0dXMgIT09IFpfU1RSRUFNX0VORCAmJiBzdGF0dXMgIT09IFpfT0spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbmZsYXRlIHByb2JsZW06ICcgKyBtZXNzYWdlc1tzdGF0dXNdKVxuICAgICAgfVxuXG4gICAgICBpZiAoc3RyZWFtLm5leHRfb3V0KSB7XG4gICAgICAgIGlmIChzdHJlYW0uYXZhaWxfb3V0ID09PSAwIHx8IHN0YXR1cyA9PT0gWl9TVFJFQU1fRU5EKSB7XG4gICAgICAgICAgb3V0cHV0ID0gc3RyZWFtLm91dHB1dC5zdWJhcnJheShzdGFydCwgc3RhcnQgPSBzdHJlYW0ubmV4dF9vdXQpXG4gICAgICAgICAgcmV0ID0gZW1pdChvdXRwdXQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IHdoaWxlICgoc3RyZWFtLmF2YWlsX2luID4gMCkgJiYgc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQpXG5cbiAgICBpZiAoc3RyZWFtLm5leHRfb3V0ID4gc3RhcnQpIHtcbiAgICAgIG91dHB1dCA9IHN0cmVhbS5vdXRwdXQuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ID0gc3RyZWFtLm5leHRfb3V0KVxuICAgICAgcmV0ID0gZW1pdChvdXRwdXQpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJldFxuICB9XG59XG4iXX0=